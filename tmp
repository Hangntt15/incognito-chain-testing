=============================================================================================================================== FAILURES ================================================================================================================================
____________________________________________________________________________________________________________ test_send_token[sender4-receiver4--1-prv-1-prv] ____________________________________________________________________________________________________________

sender = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc3290>, receiver = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc33d0>, fee = -1, fee_type = 'prv', privacy = 1, privacy_type = 'prv'

    @pytest.mark.parametrize('sender,receiver,fee,fee_type,privacy,privacy_type', [
        # 1 shard
        pytest.param(sender_account, receiver_account, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_account, 10, 'token', 1, 'prv'),
        (sender_account, receiver_account, 10, 'token', 0, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 10, 'token', 1, 'token'),
        (sender_account, receiver_account, 10, 'token', 0, 'token'),
        (sender_account, receiver_account, -1, 'prv', 1, 'token'),
        (sender_account, receiver_account, -1, 'prv', 0, 'token'),
        (sender_account, receiver_account, 1, 'prv', 1, 'token'),
        (sender_account, receiver_account, 1, 'prv', 0, 'token'),
        # # cross shard
        pytest.param(sender_account, receiver_x_shard, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'token'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'token')
    ])
    @pytest.mark.dependency(depends=["test_init_ptoken"])
    def test_send_token(sender, receiver, fee, fee_type, privacy, privacy_type):
        INFO(f'''
            Verify send Token from shard {sender.shard} to shard {receiver.shard}
            fee = {fee} {fee_type}
            privacy = {privacy}
            Privacy type = {privacy_type}
            ''')
        STEP(1, "get sender and receiver balance before sending")
        sender_token_bal_before = sender.get_token_balance(custom_token_id)
        INFO(f"Sender token balance before: {sender_token_bal_before}")
    
        sender_prv_bal_before = sender.get_prv_balance()
        INFO("sender prv balance before : " + str(sender_prv_bal_before))
    
        receiver_token_balance_before = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance before: {receiver_token_balance_before}")
    
        receiver_prv_balance_before = receiver.get_prv_balance()
        INFO(f'Receiver prv balance before: {receiver_prv_balance_before}')
    
        STEP(2, f"send token: {token_amount_to_send}. Fee {fee}:{fee_type}. Privacy {privacy}:{privacy_type}")
        if fee_type == 'prv':
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 token_privacy=privacy)
        else:  # fee_type = 'token'
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 token_privacy=privacy)
        INFO("transaction_id: " + sending_token_transaction.get_tx_id())
        assert sending_token_transaction.get_error_msg() != 'Can not create tx' and INFO(
            "make successful transaction"), sending_token_transaction.get_error_trace().get_message()
    
        STEP(3, "Subscribe sending transaction")
        transaction_result = sending_token_transaction.subscribe_transaction()
        if sender.shard != receiver.shard:
            receiver.subscribe_cross_output_token()
    
        STEP(4, '''
                checking sender and receiver bal
                sending token use prv fee then: sender prv - fee, token - sent amount only
                sending token use token fee then: sender token - fee, prv no change
                ''')
        STEP(4.1, "check sender and receiver token balance after sent")
        sender_token_bal_after = sender.get_token_balance(custom_token_id)
        INFO(f"sender_token_balance_after:{sender_token_bal_after}")
        # Balance after = balance before - amount
        if fee_type == 'prv':
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send, "sender balance incorrect"
        else:  # fee_type = 'token'
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send - fee, \
                "sender balance incorrect"
    
        receiver_token_balance_after = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance after: ")
        # Balance after = balance before + amount
        assert receiver_token_balance_before == receiver_token_balance_after - token_amount_to_send, \
            "receiver balance incorrect"
    
        STEP(4.2, "check sender and receiver PRV balance after sent")
        sender_prv_bal_after = sender.get_prv_balance()
        INFO(f"Sender prv balance after : {sender_prv_bal_after}")
        if fee_type == 'prv':
            assert sender_prv_bal_after == sender_prv_bal_before - transaction_result.get_fee(), \
                "incorrect prv balance of the address 1 "
        else:  # fee_type = 'token'
            assert sender_prv_bal_after == sender_prv_bal_before, \
                "incorrect prv balance of the address 1 "
    
        receiver_prv_balance_after = receiver.get_prv_balance()
        INFO(f"Receiver prv balance after : {receiver_prv_balance_after}")
        assert receiver_prv_balance_before == receiver_prv_balance_after, "incorrect prv balance of receiver"
    
        STEP(5, "privacy check")
        sending_token_transaction: Response
        transaction = sending_token_transaction.get_transaction_by_hash()
        if privacy == 0:  # if privacy = 0 then all privacy type must be the same
            INFO("Check transaction prv_privacy")
            assert transaction.get_proof_detail_input_coin_value_prv() != 0 and INFO(
                "info value PRV must be no privacy"), "info value PRV  is not privacy"
    
            INFO("Check transaction token privacy")
            assert transaction.get_proof_detail_input_coin_value_custom_token() != 0 and INFO(
                "info value token  must be no privacy"), "info value token is NOT privacy"
    
        else:  # privacy =1
            if privacy_type == 'token':
                INFO("Check transaction prv_privacy")
                assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV must be privacy"), "info value PRV  is privacy"
    
                INFO("Check transaction token privacy")
                assert transaction.get_proof_detail_input_coin_value_custom_token() == 0 and INFO(
                    "info value token must be privacy"), "info value token is NOT privacy"
            else:  # privacy_type  = prv while not sending prv, only token then prv privacy will be ignored
                INFO("Check transaction prv_privacy")
>               assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV is no privacy"), "info value PRV is privacy"
E               AssertionError: info value PRV is privacy
E               assert (0 is None)
E                +  where 0 = <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x1090c1c90>>()
E                +    where <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x1090c1c90>> = <IncognitoChain.Drivers.Response.Response object at 0x1090c1c90>.get_proof_detail_input_coin_value_prv

IncognitoChain/TestCases/Transactions/TRX008_init_contribute_send_custom_token.py:239: AssertionError
____________________________________________________________________________________________________________ test_send_token[sender6-receiver6-1-prv-1-prv] _____________________________________________________________________________________________________________

sender = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc3290>, receiver = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc33d0>, fee = 1, fee_type = 'prv', privacy = 1, privacy_type = 'prv'

    @pytest.mark.parametrize('sender,receiver,fee,fee_type,privacy,privacy_type', [
        # 1 shard
        pytest.param(sender_account, receiver_account, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_account, 10, 'token', 1, 'prv'),
        (sender_account, receiver_account, 10, 'token', 0, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 10, 'token', 1, 'token'),
        (sender_account, receiver_account, 10, 'token', 0, 'token'),
        (sender_account, receiver_account, -1, 'prv', 1, 'token'),
        (sender_account, receiver_account, -1, 'prv', 0, 'token'),
        (sender_account, receiver_account, 1, 'prv', 1, 'token'),
        (sender_account, receiver_account, 1, 'prv', 0, 'token'),
        # # cross shard
        pytest.param(sender_account, receiver_x_shard, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'token'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'token')
    ])
    @pytest.mark.dependency(depends=["test_init_ptoken"])
    def test_send_token(sender, receiver, fee, fee_type, privacy, privacy_type):
        INFO(f'''
            Verify send Token from shard {sender.shard} to shard {receiver.shard}
            fee = {fee} {fee_type}
            privacy = {privacy}
            Privacy type = {privacy_type}
            ''')
        STEP(1, "get sender and receiver balance before sending")
        sender_token_bal_before = sender.get_token_balance(custom_token_id)
        INFO(f"Sender token balance before: {sender_token_bal_before}")
    
        sender_prv_bal_before = sender.get_prv_balance()
        INFO("sender prv balance before : " + str(sender_prv_bal_before))
    
        receiver_token_balance_before = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance before: {receiver_token_balance_before}")
    
        receiver_prv_balance_before = receiver.get_prv_balance()
        INFO(f'Receiver prv balance before: {receiver_prv_balance_before}')
    
        STEP(2, f"send token: {token_amount_to_send}. Fee {fee}:{fee_type}. Privacy {privacy}:{privacy_type}")
        if fee_type == 'prv':
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 token_privacy=privacy)
        else:  # fee_type = 'token'
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 token_privacy=privacy)
        INFO("transaction_id: " + sending_token_transaction.get_tx_id())
        assert sending_token_transaction.get_error_msg() != 'Can not create tx' and INFO(
            "make successful transaction"), sending_token_transaction.get_error_trace().get_message()
    
        STEP(3, "Subscribe sending transaction")
        transaction_result = sending_token_transaction.subscribe_transaction()
        if sender.shard != receiver.shard:
            receiver.subscribe_cross_output_token()
    
        STEP(4, '''
                checking sender and receiver bal
                sending token use prv fee then: sender prv - fee, token - sent amount only
                sending token use token fee then: sender token - fee, prv no change
                ''')
        STEP(4.1, "check sender and receiver token balance after sent")
        sender_token_bal_after = sender.get_token_balance(custom_token_id)
        INFO(f"sender_token_balance_after:{sender_token_bal_after}")
        # Balance after = balance before - amount
        if fee_type == 'prv':
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send, "sender balance incorrect"
        else:  # fee_type = 'token'
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send - fee, \
                "sender balance incorrect"
    
        receiver_token_balance_after = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance after: ")
        # Balance after = balance before + amount
        assert receiver_token_balance_before == receiver_token_balance_after - token_amount_to_send, \
            "receiver balance incorrect"
    
        STEP(4.2, "check sender and receiver PRV balance after sent")
        sender_prv_bal_after = sender.get_prv_balance()
        INFO(f"Sender prv balance after : {sender_prv_bal_after}")
        if fee_type == 'prv':
            assert sender_prv_bal_after == sender_prv_bal_before - transaction_result.get_fee(), \
                "incorrect prv balance of the address 1 "
        else:  # fee_type = 'token'
            assert sender_prv_bal_after == sender_prv_bal_before, \
                "incorrect prv balance of the address 1 "
    
        receiver_prv_balance_after = receiver.get_prv_balance()
        INFO(f"Receiver prv balance after : {receiver_prv_balance_after}")
        assert receiver_prv_balance_before == receiver_prv_balance_after, "incorrect prv balance of receiver"
    
        STEP(5, "privacy check")
        sending_token_transaction: Response
        transaction = sending_token_transaction.get_transaction_by_hash()
        if privacy == 0:  # if privacy = 0 then all privacy type must be the same
            INFO("Check transaction prv_privacy")
            assert transaction.get_proof_detail_input_coin_value_prv() != 0 and INFO(
                "info value PRV must be no privacy"), "info value PRV  is not privacy"
    
            INFO("Check transaction token privacy")
            assert transaction.get_proof_detail_input_coin_value_custom_token() != 0 and INFO(
                "info value token  must be no privacy"), "info value token is NOT privacy"
    
        else:  # privacy =1
            if privacy_type == 'token':
                INFO("Check transaction prv_privacy")
                assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV must be privacy"), "info value PRV  is privacy"
    
                INFO("Check transaction token privacy")
                assert transaction.get_proof_detail_input_coin_value_custom_token() == 0 and INFO(
                    "info value token must be privacy"), "info value token is NOT privacy"
            else:  # privacy_type  = prv while not sending prv, only token then prv privacy will be ignored
                INFO("Check transaction prv_privacy")
>               assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV is no privacy"), "info value PRV is privacy"
E               AssertionError: info value PRV is privacy
E               assert (0 is None)
E                +  where 0 = <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x1092147d0>>()
E                +    where <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x1092147d0>> = <IncognitoChain.Drivers.Response.Response object at 0x1092147d0>.get_proof_detail_input_coin_value_prv

IncognitoChain/TestCases/Transactions/TRX008_init_contribute_send_custom_token.py:239: AssertionError
__________________________________________________________________________________________________________ test_send_token[sender10-receiver10--1-prv-1-token] __________________________________________________________________________________________________________

sender = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc3290>, receiver = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc33d0>, fee = -1, fee_type = 'prv', privacy = 1, privacy_type = 'token'

    @pytest.mark.parametrize('sender,receiver,fee,fee_type,privacy,privacy_type', [
        # 1 shard
        pytest.param(sender_account, receiver_account, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_account, 10, 'token', 1, 'prv'),
        (sender_account, receiver_account, 10, 'token', 0, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 10, 'token', 1, 'token'),
        (sender_account, receiver_account, 10, 'token', 0, 'token'),
        (sender_account, receiver_account, -1, 'prv', 1, 'token'),
        (sender_account, receiver_account, -1, 'prv', 0, 'token'),
        (sender_account, receiver_account, 1, 'prv', 1, 'token'),
        (sender_account, receiver_account, 1, 'prv', 0, 'token'),
        # # cross shard
        pytest.param(sender_account, receiver_x_shard, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'token'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'token')
    ])
    @pytest.mark.dependency(depends=["test_init_ptoken"])
    def test_send_token(sender, receiver, fee, fee_type, privacy, privacy_type):
        INFO(f'''
            Verify send Token from shard {sender.shard} to shard {receiver.shard}
            fee = {fee} {fee_type}
            privacy = {privacy}
            Privacy type = {privacy_type}
            ''')
        STEP(1, "get sender and receiver balance before sending")
        sender_token_bal_before = sender.get_token_balance(custom_token_id)
        INFO(f"Sender token balance before: {sender_token_bal_before}")
    
        sender_prv_bal_before = sender.get_prv_balance()
        INFO("sender prv balance before : " + str(sender_prv_bal_before))
    
        receiver_token_balance_before = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance before: {receiver_token_balance_before}")
    
        receiver_prv_balance_before = receiver.get_prv_balance()
        INFO(f'Receiver prv balance before: {receiver_prv_balance_before}')
    
        STEP(2, f"send token: {token_amount_to_send}. Fee {fee}:{fee_type}. Privacy {privacy}:{privacy_type}")
        if fee_type == 'prv':
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 token_privacy=privacy)
        else:  # fee_type = 'token'
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 token_privacy=privacy)
        INFO("transaction_id: " + sending_token_transaction.get_tx_id())
        assert sending_token_transaction.get_error_msg() != 'Can not create tx' and INFO(
            "make successful transaction"), sending_token_transaction.get_error_trace().get_message()
    
        STEP(3, "Subscribe sending transaction")
        transaction_result = sending_token_transaction.subscribe_transaction()
        if sender.shard != receiver.shard:
            receiver.subscribe_cross_output_token()
    
        STEP(4, '''
                checking sender and receiver bal
                sending token use prv fee then: sender prv - fee, token - sent amount only
                sending token use token fee then: sender token - fee, prv no change
                ''')
        STEP(4.1, "check sender and receiver token balance after sent")
        sender_token_bal_after = sender.get_token_balance(custom_token_id)
        INFO(f"sender_token_balance_after:{sender_token_bal_after}")
        # Balance after = balance before - amount
        if fee_type == 'prv':
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send, "sender balance incorrect"
        else:  # fee_type = 'token'
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send - fee, \
                "sender balance incorrect"
    
        receiver_token_balance_after = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance after: ")
        # Balance after = balance before + amount
        assert receiver_token_balance_before == receiver_token_balance_after - token_amount_to_send, \
            "receiver balance incorrect"
    
        STEP(4.2, "check sender and receiver PRV balance after sent")
        sender_prv_bal_after = sender.get_prv_balance()
        INFO(f"Sender prv balance after : {sender_prv_bal_after}")
        if fee_type == 'prv':
            assert sender_prv_bal_after == sender_prv_bal_before - transaction_result.get_fee(), \
                "incorrect prv balance of the address 1 "
        else:  # fee_type = 'token'
            assert sender_prv_bal_after == sender_prv_bal_before, \
                "incorrect prv balance of the address 1 "
    
        receiver_prv_balance_after = receiver.get_prv_balance()
        INFO(f"Receiver prv balance after : {receiver_prv_balance_after}")
        assert receiver_prv_balance_before == receiver_prv_balance_after, "incorrect prv balance of receiver"
    
        STEP(5, "privacy check")
        sending_token_transaction: Response
        transaction = sending_token_transaction.get_transaction_by_hash()
        if privacy == 0:  # if privacy = 0 then all privacy type must be the same
            INFO("Check transaction prv_privacy")
            assert transaction.get_proof_detail_input_coin_value_prv() != 0 and INFO(
                "info value PRV must be no privacy"), "info value PRV  is not privacy"
    
            INFO("Check transaction token privacy")
            assert transaction.get_proof_detail_input_coin_value_custom_token() != 0 and INFO(
                "info value token  must be no privacy"), "info value token is NOT privacy"
    
        else:  # privacy =1
            if privacy_type == 'token':
                INFO("Check transaction prv_privacy")
>               assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV must be privacy"), "info value PRV  is privacy"
E               AssertionError: info value PRV  is privacy
E               assert (719999999988648 is None)
E                +  where 719999999988648 = <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109481690>>()
E                +    where <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109481690>> = <IncognitoChain.Drivers.Response.Response object at 0x109481690>.get_proof_detail_input_coin_value_prv

IncognitoChain/TestCases/Transactions/TRX008_init_contribute_send_custom_token.py:231: AssertionError
__________________________________________________________________________________________________________ test_send_token[sender12-receiver12-1-prv-1-token] ___________________________________________________________________________________________________________

sender = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc3290>, receiver = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc33d0>, fee = 1, fee_type = 'prv', privacy = 1, privacy_type = 'token'

    @pytest.mark.parametrize('sender,receiver,fee,fee_type,privacy,privacy_type', [
        # 1 shard
        pytest.param(sender_account, receiver_account, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_account, 10, 'token', 1, 'prv'),
        (sender_account, receiver_account, 10, 'token', 0, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 10, 'token', 1, 'token'),
        (sender_account, receiver_account, 10, 'token', 0, 'token'),
        (sender_account, receiver_account, -1, 'prv', 1, 'token'),
        (sender_account, receiver_account, -1, 'prv', 0, 'token'),
        (sender_account, receiver_account, 1, 'prv', 1, 'token'),
        (sender_account, receiver_account, 1, 'prv', 0, 'token'),
        # # cross shard
        pytest.param(sender_account, receiver_x_shard, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'token'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'token')
    ])
    @pytest.mark.dependency(depends=["test_init_ptoken"])
    def test_send_token(sender, receiver, fee, fee_type, privacy, privacy_type):
        INFO(f'''
            Verify send Token from shard {sender.shard} to shard {receiver.shard}
            fee = {fee} {fee_type}
            privacy = {privacy}
            Privacy type = {privacy_type}
            ''')
        STEP(1, "get sender and receiver balance before sending")
        sender_token_bal_before = sender.get_token_balance(custom_token_id)
        INFO(f"Sender token balance before: {sender_token_bal_before}")
    
        sender_prv_bal_before = sender.get_prv_balance()
        INFO("sender prv balance before : " + str(sender_prv_bal_before))
    
        receiver_token_balance_before = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance before: {receiver_token_balance_before}")
    
        receiver_prv_balance_before = receiver.get_prv_balance()
        INFO(f'Receiver prv balance before: {receiver_prv_balance_before}')
    
        STEP(2, f"send token: {token_amount_to_send}. Fee {fee}:{fee_type}. Privacy {privacy}:{privacy_type}")
        if fee_type == 'prv':
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 token_privacy=privacy)
        else:  # fee_type = 'token'
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 token_privacy=privacy)
        INFO("transaction_id: " + sending_token_transaction.get_tx_id())
        assert sending_token_transaction.get_error_msg() != 'Can not create tx' and INFO(
            "make successful transaction"), sending_token_transaction.get_error_trace().get_message()
    
        STEP(3, "Subscribe sending transaction")
        transaction_result = sending_token_transaction.subscribe_transaction()
        if sender.shard != receiver.shard:
            receiver.subscribe_cross_output_token()
    
        STEP(4, '''
                checking sender and receiver bal
                sending token use prv fee then: sender prv - fee, token - sent amount only
                sending token use token fee then: sender token - fee, prv no change
                ''')
        STEP(4.1, "check sender and receiver token balance after sent")
        sender_token_bal_after = sender.get_token_balance(custom_token_id)
        INFO(f"sender_token_balance_after:{sender_token_bal_after}")
        # Balance after = balance before - amount
        if fee_type == 'prv':
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send, "sender balance incorrect"
        else:  # fee_type = 'token'
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send - fee, \
                "sender balance incorrect"
    
        receiver_token_balance_after = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance after: ")
        # Balance after = balance before + amount
        assert receiver_token_balance_before == receiver_token_balance_after - token_amount_to_send, \
            "receiver balance incorrect"
    
        STEP(4.2, "check sender and receiver PRV balance after sent")
        sender_prv_bal_after = sender.get_prv_balance()
        INFO(f"Sender prv balance after : {sender_prv_bal_after}")
        if fee_type == 'prv':
            assert sender_prv_bal_after == sender_prv_bal_before - transaction_result.get_fee(), \
                "incorrect prv balance of the address 1 "
        else:  # fee_type = 'token'
            assert sender_prv_bal_after == sender_prv_bal_before, \
                "incorrect prv balance of the address 1 "
    
        receiver_prv_balance_after = receiver.get_prv_balance()
        INFO(f"Receiver prv balance after : {receiver_prv_balance_after}")
        assert receiver_prv_balance_before == receiver_prv_balance_after, "incorrect prv balance of receiver"
    
        STEP(5, "privacy check")
        sending_token_transaction: Response
        transaction = sending_token_transaction.get_transaction_by_hash()
        if privacy == 0:  # if privacy = 0 then all privacy type must be the same
            INFO("Check transaction prv_privacy")
            assert transaction.get_proof_detail_input_coin_value_prv() != 0 and INFO(
                "info value PRV must be no privacy"), "info value PRV  is not privacy"
    
            INFO("Check transaction token privacy")
            assert transaction.get_proof_detail_input_coin_value_custom_token() != 0 and INFO(
                "info value token  must be no privacy"), "info value token is NOT privacy"
    
        else:  # privacy =1
            if privacy_type == 'token':
                INFO("Check transaction prv_privacy")
>               assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV must be privacy"), "info value PRV  is privacy"
E               AssertionError: info value PRV  is privacy
E               assert (719999999988640 is None)
E                +  where 719999999988640 = <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x1095f0250>>()
E                +    where <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x1095f0250>> = <IncognitoChain.Drivers.Response.Response object at 0x1095f0250>.get_proof_detail_input_coin_value_prv

IncognitoChain/TestCases/Transactions/TRX008_init_contribute_send_custom_token.py:231: AssertionError
___________________________________________________________________________________________________________ test_send_token[sender18-receiver18--1-prv-1-prv] ___________________________________________________________________________________________________________

sender = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc3290>, receiver = <IncognitoChain.Objects.AccountObject.Account object at 0x107ca8a90>, fee = -1, fee_type = 'prv', privacy = 1, privacy_type = 'prv'

    @pytest.mark.parametrize('sender,receiver,fee,fee_type,privacy,privacy_type', [
        # 1 shard
        pytest.param(sender_account, receiver_account, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_account, 10, 'token', 1, 'prv'),
        (sender_account, receiver_account, 10, 'token', 0, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 10, 'token', 1, 'token'),
        (sender_account, receiver_account, 10, 'token', 0, 'token'),
        (sender_account, receiver_account, -1, 'prv', 1, 'token'),
        (sender_account, receiver_account, -1, 'prv', 0, 'token'),
        (sender_account, receiver_account, 1, 'prv', 1, 'token'),
        (sender_account, receiver_account, 1, 'prv', 0, 'token'),
        # # cross shard
        pytest.param(sender_account, receiver_x_shard, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'token'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'token')
    ])
    @pytest.mark.dependency(depends=["test_init_ptoken"])
    def test_send_token(sender, receiver, fee, fee_type, privacy, privacy_type):
        INFO(f'''
            Verify send Token from shard {sender.shard} to shard {receiver.shard}
            fee = {fee} {fee_type}
            privacy = {privacy}
            Privacy type = {privacy_type}
            ''')
        STEP(1, "get sender and receiver balance before sending")
        sender_token_bal_before = sender.get_token_balance(custom_token_id)
        INFO(f"Sender token balance before: {sender_token_bal_before}")
    
        sender_prv_bal_before = sender.get_prv_balance()
        INFO("sender prv balance before : " + str(sender_prv_bal_before))
    
        receiver_token_balance_before = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance before: {receiver_token_balance_before}")
    
        receiver_prv_balance_before = receiver.get_prv_balance()
        INFO(f'Receiver prv balance before: {receiver_prv_balance_before}')
    
        STEP(2, f"send token: {token_amount_to_send}. Fee {fee}:{fee_type}. Privacy {privacy}:{privacy_type}")
        if fee_type == 'prv':
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 token_privacy=privacy)
        else:  # fee_type = 'token'
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 token_privacy=privacy)
        INFO("transaction_id: " + sending_token_transaction.get_tx_id())
        assert sending_token_transaction.get_error_msg() != 'Can not create tx' and INFO(
            "make successful transaction"), sending_token_transaction.get_error_trace().get_message()
    
        STEP(3, "Subscribe sending transaction")
        transaction_result = sending_token_transaction.subscribe_transaction()
        if sender.shard != receiver.shard:
            receiver.subscribe_cross_output_token()
    
        STEP(4, '''
                checking sender and receiver bal
                sending token use prv fee then: sender prv - fee, token - sent amount only
                sending token use token fee then: sender token - fee, prv no change
                ''')
        STEP(4.1, "check sender and receiver token balance after sent")
        sender_token_bal_after = sender.get_token_balance(custom_token_id)
        INFO(f"sender_token_balance_after:{sender_token_bal_after}")
        # Balance after = balance before - amount
        if fee_type == 'prv':
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send, "sender balance incorrect"
        else:  # fee_type = 'token'
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send - fee, \
                "sender balance incorrect"
    
        receiver_token_balance_after = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance after: ")
        # Balance after = balance before + amount
        assert receiver_token_balance_before == receiver_token_balance_after - token_amount_to_send, \
            "receiver balance incorrect"
    
        STEP(4.2, "check sender and receiver PRV balance after sent")
        sender_prv_bal_after = sender.get_prv_balance()
        INFO(f"Sender prv balance after : {sender_prv_bal_after}")
        if fee_type == 'prv':
            assert sender_prv_bal_after == sender_prv_bal_before - transaction_result.get_fee(), \
                "incorrect prv balance of the address 1 "
        else:  # fee_type = 'token'
            assert sender_prv_bal_after == sender_prv_bal_before, \
                "incorrect prv balance of the address 1 "
    
        receiver_prv_balance_after = receiver.get_prv_balance()
        INFO(f"Receiver prv balance after : {receiver_prv_balance_after}")
        assert receiver_prv_balance_before == receiver_prv_balance_after, "incorrect prv balance of receiver"
    
        STEP(5, "privacy check")
        sending_token_transaction: Response
        transaction = sending_token_transaction.get_transaction_by_hash()
        if privacy == 0:  # if privacy = 0 then all privacy type must be the same
            INFO("Check transaction prv_privacy")
            assert transaction.get_proof_detail_input_coin_value_prv() != 0 and INFO(
                "info value PRV must be no privacy"), "info value PRV  is not privacy"
    
            INFO("Check transaction token privacy")
            assert transaction.get_proof_detail_input_coin_value_custom_token() != 0 and INFO(
                "info value token  must be no privacy"), "info value token is NOT privacy"
    
        else:  # privacy =1
            if privacy_type == 'token':
                INFO("Check transaction prv_privacy")
                assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV must be privacy"), "info value PRV  is privacy"
    
                INFO("Check transaction token privacy")
                assert transaction.get_proof_detail_input_coin_value_custom_token() == 0 and INFO(
                    "info value token must be privacy"), "info value token is NOT privacy"
            else:  # privacy_type  = prv while not sending prv, only token then prv privacy will be ignored
                INFO("Check transaction prv_privacy")
>               assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV is no privacy"), "info value PRV is privacy"
E               AssertionError: info value PRV is privacy
E               assert (0 is None)
E                +  where 0 = <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109937610>>()
E                +    where <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109937610>> = <IncognitoChain.Drivers.Response.Response object at 0x109937610>.get_proof_detail_input_coin_value_prv

IncognitoChain/TestCases/Transactions/TRX008_init_contribute_send_custom_token.py:239: AssertionError
___________________________________________________________________________________________________________ test_send_token[sender20-receiver20-1-prv-1-prv] ____________________________________________________________________________________________________________

sender = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc3290>, receiver = <IncognitoChain.Objects.AccountObject.Account object at 0x107ca8a90>, fee = 1, fee_type = 'prv', privacy = 1, privacy_type = 'prv'

    @pytest.mark.parametrize('sender,receiver,fee,fee_type,privacy,privacy_type', [
        # 1 shard
        pytest.param(sender_account, receiver_account, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_account, 10, 'token', 1, 'prv'),
        (sender_account, receiver_account, 10, 'token', 0, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 10, 'token', 1, 'token'),
        (sender_account, receiver_account, 10, 'token', 0, 'token'),
        (sender_account, receiver_account, -1, 'prv', 1, 'token'),
        (sender_account, receiver_account, -1, 'prv', 0, 'token'),
        (sender_account, receiver_account, 1, 'prv', 1, 'token'),
        (sender_account, receiver_account, 1, 'prv', 0, 'token'),
        # # cross shard
        pytest.param(sender_account, receiver_x_shard, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'token'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'token')
    ])
    @pytest.mark.dependency(depends=["test_init_ptoken"])
    def test_send_token(sender, receiver, fee, fee_type, privacy, privacy_type):
        INFO(f'''
            Verify send Token from shard {sender.shard} to shard {receiver.shard}
            fee = {fee} {fee_type}
            privacy = {privacy}
            Privacy type = {privacy_type}
            ''')
        STEP(1, "get sender and receiver balance before sending")
        sender_token_bal_before = sender.get_token_balance(custom_token_id)
        INFO(f"Sender token balance before: {sender_token_bal_before}")
    
        sender_prv_bal_before = sender.get_prv_balance()
        INFO("sender prv balance before : " + str(sender_prv_bal_before))
    
        receiver_token_balance_before = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance before: {receiver_token_balance_before}")
    
        receiver_prv_balance_before = receiver.get_prv_balance()
        INFO(f'Receiver prv balance before: {receiver_prv_balance_before}')
    
        STEP(2, f"send token: {token_amount_to_send}. Fee {fee}:{fee_type}. Privacy {privacy}:{privacy_type}")
        if fee_type == 'prv':
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 token_privacy=privacy)
        else:  # fee_type = 'token'
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 token_privacy=privacy)
        INFO("transaction_id: " + sending_token_transaction.get_tx_id())
        assert sending_token_transaction.get_error_msg() != 'Can not create tx' and INFO(
            "make successful transaction"), sending_token_transaction.get_error_trace().get_message()
    
        STEP(3, "Subscribe sending transaction")
        transaction_result = sending_token_transaction.subscribe_transaction()
        if sender.shard != receiver.shard:
            receiver.subscribe_cross_output_token()
    
        STEP(4, '''
                checking sender and receiver bal
                sending token use prv fee then: sender prv - fee, token - sent amount only
                sending token use token fee then: sender token - fee, prv no change
                ''')
        STEP(4.1, "check sender and receiver token balance after sent")
        sender_token_bal_after = sender.get_token_balance(custom_token_id)
        INFO(f"sender_token_balance_after:{sender_token_bal_after}")
        # Balance after = balance before - amount
        if fee_type == 'prv':
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send, "sender balance incorrect"
        else:  # fee_type = 'token'
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send - fee, \
                "sender balance incorrect"
    
        receiver_token_balance_after = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance after: ")
        # Balance after = balance before + amount
        assert receiver_token_balance_before == receiver_token_balance_after - token_amount_to_send, \
            "receiver balance incorrect"
    
        STEP(4.2, "check sender and receiver PRV balance after sent")
        sender_prv_bal_after = sender.get_prv_balance()
        INFO(f"Sender prv balance after : {sender_prv_bal_after}")
        if fee_type == 'prv':
            assert sender_prv_bal_after == sender_prv_bal_before - transaction_result.get_fee(), \
                "incorrect prv balance of the address 1 "
        else:  # fee_type = 'token'
            assert sender_prv_bal_after == sender_prv_bal_before, \
                "incorrect prv balance of the address 1 "
    
        receiver_prv_balance_after = receiver.get_prv_balance()
        INFO(f"Receiver prv balance after : {receiver_prv_balance_after}")
        assert receiver_prv_balance_before == receiver_prv_balance_after, "incorrect prv balance of receiver"
    
        STEP(5, "privacy check")
        sending_token_transaction: Response
        transaction = sending_token_transaction.get_transaction_by_hash()
        if privacy == 0:  # if privacy = 0 then all privacy type must be the same
            INFO("Check transaction prv_privacy")
            assert transaction.get_proof_detail_input_coin_value_prv() != 0 and INFO(
                "info value PRV must be no privacy"), "info value PRV  is not privacy"
    
            INFO("Check transaction token privacy")
            assert transaction.get_proof_detail_input_coin_value_custom_token() != 0 and INFO(
                "info value token  must be no privacy"), "info value token is NOT privacy"
    
        else:  # privacy =1
            if privacy_type == 'token':
                INFO("Check transaction prv_privacy")
                assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV must be privacy"), "info value PRV  is privacy"
    
                INFO("Check transaction token privacy")
                assert transaction.get_proof_detail_input_coin_value_custom_token() == 0 and INFO(
                    "info value token must be privacy"), "info value token is NOT privacy"
            else:  # privacy_type  = prv while not sending prv, only token then prv privacy will be ignored
                INFO("Check transaction prv_privacy")
>               assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV is no privacy"), "info value PRV is privacy"
E               AssertionError: info value PRV is privacy
E               assert (0 is None)
E                +  where 0 = <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109ac8f10>>()
E                +    where <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109ac8f10>> = <IncognitoChain.Drivers.Response.Response object at 0x109ac8f10>.get_proof_detail_input_coin_value_prv

IncognitoChain/TestCases/Transactions/TRX008_init_contribute_send_custom_token.py:239: AssertionError
__________________________________________________________________________________________________________ test_send_token[sender24-receiver24--1-prv-1-token] __________________________________________________________________________________________________________

sender = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc3290>, receiver = <IncognitoChain.Objects.AccountObject.Account object at 0x107ca8a90>, fee = -1, fee_type = 'prv', privacy = 1, privacy_type = 'token'

    @pytest.mark.parametrize('sender,receiver,fee,fee_type,privacy,privacy_type', [
        # 1 shard
        pytest.param(sender_account, receiver_account, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_account, 10, 'token', 1, 'prv'),
        (sender_account, receiver_account, 10, 'token', 0, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_account, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_account, 10, 'token', 1, 'token'),
        (sender_account, receiver_account, 10, 'token', 0, 'token'),
        (sender_account, receiver_account, -1, 'prv', 1, 'token'),
        (sender_account, receiver_account, -1, 'prv', 0, 'token'),
        (sender_account, receiver_account, 1, 'prv', 1, 'token'),
        (sender_account, receiver_account, 1, 'prv', 0, 'token'),
        # # cross shard
        pytest.param(sender_account, receiver_x_shard, -1, 'token', 1, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        pytest.param(sender_account, receiver_account, -1, 'token', 0, 'prv',
                     marks=pytest.mark.xfail(reason="Cannot set token fee =-1")),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'prv'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'prv'),
        (sender_account, receiver_x_shard, 10, 'token', 1, 'token'),
        (sender_account, receiver_x_shard, 10, 'token', 0, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, -1, 'prv', 0, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 1, 'token'),
        (sender_account, receiver_x_shard, 1, 'prv', 0, 'token')
    ])
    @pytest.mark.dependency(depends=["test_init_ptoken"])
    def test_send_token(sender, receiver, fee, fee_type, privacy, privacy_type):
        INFO(f'''
            Verify send Token from shard {sender.shard} to shard {receiver.shard}
            fee = {fee} {fee_type}
            privacy = {privacy}
            Privacy type = {privacy_type}
            ''')
        STEP(1, "get sender and receiver balance before sending")
        sender_token_bal_before = sender.get_token_balance(custom_token_id)
        INFO(f"Sender token balance before: {sender_token_bal_before}")
    
        sender_prv_bal_before = sender.get_prv_balance()
        INFO("sender prv balance before : " + str(sender_prv_bal_before))
    
        receiver_token_balance_before = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance before: {receiver_token_balance_before}")
    
        receiver_prv_balance_before = receiver.get_prv_balance()
        INFO(f'Receiver prv balance before: {receiver_prv_balance_before}')
    
        STEP(2, f"send token: {token_amount_to_send}. Fee {fee}:{fee_type}. Privacy {privacy}:{privacy_type}")
        if fee_type == 'prv':
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, prv_fee=fee,
                                                                 token_privacy=privacy)
        else:  # fee_type = 'token'
            if privacy_type == 'prv':
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 prv_privacy=privacy)
            else:
                sending_token_transaction = sender.send_token_to(receiver, custom_token_id,
                                                                 token_amount_to_send, token_fee=fee,
                                                                 token_privacy=privacy)
        INFO("transaction_id: " + sending_token_transaction.get_tx_id())
        assert sending_token_transaction.get_error_msg() != 'Can not create tx' and INFO(
            "make successful transaction"), sending_token_transaction.get_error_trace().get_message()
    
        STEP(3, "Subscribe sending transaction")
        transaction_result = sending_token_transaction.subscribe_transaction()
        if sender.shard != receiver.shard:
            receiver.subscribe_cross_output_token()
    
        STEP(4, '''
                checking sender and receiver bal
                sending token use prv fee then: sender prv - fee, token - sent amount only
                sending token use token fee then: sender token - fee, prv no change
                ''')
        STEP(4.1, "check sender and receiver token balance after sent")
        sender_token_bal_after = sender.get_token_balance(custom_token_id)
        INFO(f"sender_token_balance_after:{sender_token_bal_after}")
        # Balance after = balance before - amount
        if fee_type == 'prv':
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send, "sender balance incorrect"
        else:  # fee_type = 'token'
            assert sender_token_bal_after == sender_token_bal_before - token_amount_to_send - fee, \
                "sender balance incorrect"
    
        receiver_token_balance_after = receiver.get_token_balance(custom_token_id)
        INFO(f"Receiver token balance after: ")
        # Balance after = balance before + amount
        assert receiver_token_balance_before == receiver_token_balance_after - token_amount_to_send, \
            "receiver balance incorrect"
    
        STEP(4.2, "check sender and receiver PRV balance after sent")
        sender_prv_bal_after = sender.get_prv_balance()
        INFO(f"Sender prv balance after : {sender_prv_bal_after}")
        if fee_type == 'prv':
            assert sender_prv_bal_after == sender_prv_bal_before - transaction_result.get_fee(), \
                "incorrect prv balance of the address 1 "
        else:  # fee_type = 'token'
            assert sender_prv_bal_after == sender_prv_bal_before, \
                "incorrect prv balance of the address 1 "
    
        receiver_prv_balance_after = receiver.get_prv_balance()
        INFO(f"Receiver prv balance after : {receiver_prv_balance_after}")
        assert receiver_prv_balance_before == receiver_prv_balance_after, "incorrect prv balance of receiver"
    
        STEP(5, "privacy check")
        sending_token_transaction: Response
        transaction = sending_token_transaction.get_transaction_by_hash()
        if privacy == 0:  # if privacy = 0 then all privacy type must be the same
            INFO("Check transaction prv_privacy")
            assert transaction.get_proof_detail_input_coin_value_prv() != 0 and INFO(
                "info value PRV must be no privacy"), "info value PRV  is not privacy"
    
            INFO("Check transaction token privacy")
            assert transaction.get_proof_detail_input_coin_value_custom_token() != 0 and INFO(
                "info value token  must be no privacy"), "info value token is NOT privacy"
    
        else:  # privacy =1
            if privacy_type == 'token':
                INFO("Check transaction prv_privacy")
>               assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV must be privacy"), "info value PRV  is privacy"
E               AssertionError: info value PRV  is privacy
E               assert (719999999988612 is None)
E                +  where 719999999988612 = <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109d35ed0>>()
E                +    where <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109d35ed0>> = <IncognitoChain.Drivers.Response.Response object at 0x109d35ed0>.get_proof_detail_input_coin_value_prv

IncognitoChain/TestCases/Transactions/TRX008_init_contribute_send_custom_token.py:231: AssertionError
__________________________________________________________________________________________________________ test_send_token[sender26-receiver26-1-prv-1-token] ___________________________________________________________________________________________________________

sender = <IncognitoChain.Objects.AccountObject.Account object at 0x107cc3290>, receiver = <IncognitoChain.Objects.AccountObject.Account object at 0x107ca8a90>,
 fee = 1, fee_type = 'prv', privacy = 1, privacy_type = 'token'

    @pytest.mark.dependency(depends=["test_init_ptoken"])
    def test_send_token(sender, receiver, fee, fee_type, privacy, privacy_type):
 ..
        STEP(5, "privacy check")
        sending_token_transaction: Response
        transaction = sending_token_transaction.get_transaction_by_hash()
        if privacy == 0:  # if privacy = 0 then all privacy type must be the same
            INFO("Check transaction prv_privacy")
            assert transaction.get_proof_detail_input_coin_value_prv() != 0 and INFO(
                "info value PRV must be no privacy"), "info value PRV  is not privacy"
    
            INFO("Check transaction token privacy")
            assert transaction.get_proof_detail_input_coin_value_custom_token() != 0 and INFO(
                "info value token  must be no privacy"), "info value token is NOT privacy"
    
        else:  # privacy =1
            if privacy_type == 'token':
                INFO("Check transaction prv_privacy")
>               assert transaction.get_proof_detail_input_coin_value_prv() is None and INFO(
                    "info value PRV must be privacy"), "info value PRV  is privacy"
E               AssertionError: info value PRV  is privacy
E               assert (719999999988604 is None)
E                +  where 719999999988604 = <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109ecb650>>()
E                +    where <bound method Response.get_proof_detail_input_coin_value_prv of <IncognitoChain.Drivers.Response.Response object at 0x109ecb650>> = <IncognitoChain.Drivers.Response.Response object at 0x109ecb650>.get_proof_detail_input_coin_value_prv

IncognitoChain/TestCases/Transactions/TRX008_init_contribute_send_custom_token.py:231: AssertionError